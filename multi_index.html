<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module multi_index</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module multi_index</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>Multi index implements a key - value dictionary which stores values  
based on multiple keys.

<p><b>Authors:</b> Gregory Rogers (<a href="mailto:greg.r.rogers@gmail.com"><tt>greg.r.rogers@gmail.com</tt></a>).</p>

<h2><a name="description">Description</a></h2><p>Multi index implements a key - value dictionary which stores values  
based on multiple keys. Multi index only stores values, the keys used for  
indices are derived from the values by user defined key functions. There can  
be multiple indices, and it is possible to look up values based on any of  
these indices. A common use case is to store tuples, which can be looked up  
by each of their elements.</p>
 
  <p>When creating indices, an <i>index type</i> and a <i>key function</i> are
  needed. The key function takes a value and generates a key from it to be
  used in indexing the values.  There are two types of indices available -
  <i>ordered_unique</i> and <i>ordered_non_unique</i>.  Both of these indices
  store values in order based on the key. With an ordered_unique index, keys
  derived from values cannot compare the same as any other key for that index,
  this comparison is done with <code>==</code> operator. When calling
  functions that take an <i>IndexNum</i>, the index num is the position in the
  list of indices given to <a href="#new-1"><code>new/1</code></a>, for example in the multi index
  <code>MI = multi_index:new([{ordered_non_unique, fun x/1}, {ordered_unique,
  fun y/1}])</code> the non-unique index with function x is index 1, and the  
unique index with function y is index 2.</p>
 
  <h3><a name="EXAMPLES">EXAMPLES</a></h3>
  Example of an employee list using a multi index to look up employees by
  various fields.
  <code><pre>
  -module(employee_list).
 
  -define(BY_NAME, 1).
  -define(BY_JOB, 2).
 
  -export([new/0, hire/3, fire/2, department_list/2]).
 
  new() -&gt;
      multi_index:new([{ordered_unique, fun(X) -&gt; element(1, X) end},
              {ordered_non_unique, fun(X) -&gt; element(2, X) end}]).
 
  hire(Name, Job, Employees) -&gt;
      case multi_index:try_insert({Name, Job}, Employees) of
          {ok, NewEmployees} -&gt; {ok, NewEmployees};
          error -&gt; {error, "This employee already works here"}
      end.
 
  fire(Name, Employees) -&gt;
      case multi_index:fetch_all(Name, ?BY_NAME, Employees) of
          [_Emp] -&gt; {ok, multi_index:erase(Name, ?BY_NAME, Employees)};
          _ -&gt; {error, "This employee does not work here"}
      end.
 
  department_list(Job, Employees) -&gt;
      multi_index:fetch_all(Job, ?BY_JOB, Employees).
  </pre></code>
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-index">index()</a></h3>
<p><tt>index() = {ordered_unique, <a href="#type-key_function">key_function()</a>} | {ordered_non_unique, <a href="#type-key_function">key_function()</a>}</tt></p>
<p><p><i>ordered_unique</i> - generates a unique index where values are ordered by  
their keys, which are obtained by calling the key function on each value.</p>
 
  <i>ordered_non_unique</i> - generates a non-unique index where values are
  ordered by their keys, which are obtained by calling the key function on
  each value.</p>

<h3 class="typedecl"><a name="type-key_function">key_function()</a></h3>
<p><tt>key_function() = function((term()) -&gt; term())</tt></p>
<p>A function which, when
  given a value, returns a corresponding key used to index that value.</p>

<h3 class="typedecl"><a name="type-multi_index">multi_index()</a></h3>
<p><b>abstract datatype</b>: <tt>multi_index()</tt></p>
<p>An opaque term representing a multi index.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#erase-3">erase/3</a></td><td>Erases all elements, if any, from the multi index <code>MI</code> whose
  key for index number <code>IndexNum</code> matches <code>Key</code>.</td></tr>
<tr><td valign="top"><a href="#fetch-3">fetch/3</a></td><td>Fetches and returns a single element from the multi index
  <code>MI</code> whose key for index number <code>IndexNum</code> matches
  <code>Key</code>.</td></tr>
<tr><td valign="top"><a href="#fetch_all-3">fetch_all/3</a></td><td>Looks up and returns a possibly empty list of all values in the multi
  index <code>MI</code> and whose key for index number <code>IndexNum</code>
  matches <code>Key</code>.</td></tr>
<tr><td valign="top"><a href="#from_list-2">from_list/2</a></td><td>Returns a new multi index whose elements are the elements in
  <code>Values</code>, and with indicse <code>Indices</code>.</td></tr>
<tr><td valign="top"><a href="#indices-1">indices/1</a></td><td>Returns the indices used in the multi index <code>MI</code>.</td></tr>
<tr><td valign="top"><a href="#insert-2">insert/2</a></td><td>Inserts the element <code>Value</code> into the multi index
  <code>MI</code> and returns the resulting multi index.</td></tr>
<tr><td valign="top"><a href="#new-1">new/1</a></td><td>Returns an empty multi index with indices <code>Indices</code>.</td></tr>
<tr><td valign="top"><a href="#replace-3">replace/3</a></td><td>Replaces all instances of <code>Value1</code> with <code>Value2</code>
  in the multi index <code>MI</code> and returns the resulting multi index.</td></tr>
<tr><td valign="top"><a href="#size-1">size/1</a></td><td>Returns the number of elements stored in the multi index
  <code>MI</code>.</td></tr>
<tr><td valign="top"><a href="#to_list-2">to_list/2</a></td><td>Returns a list of all values in the multi index <code>MI</code>, in the
  order of their keys for index number <code>IndexNum</code>.</td></tr>
<tr><td valign="top"><a href="#try_insert-2">try_insert/2</a></td><td>Attempt to insert the element <code>Value</code> into the multi index
  <code>MI1</code>.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="erase-3">erase/3</a></h3>
<div class="spec">
<p><tt>erase(Key, IndexNum, MI) -&gt; <a href="#type-multi_index">multi_index()</a></tt>
<ul class="definitions"><li><tt>Key = term()</tt></li>
<li><tt>IndexNum = integer()</tt></li>
<li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
</ul></p>
</div><p>Erases all elements, if any, from the multi index <code>MI</code> whose
  key for index number <code>IndexNum</code> matches <code>Key</code>. The
  resulting multi index is returned.</p>

<h3 class="function"><a name="fetch-3">fetch/3</a></h3>
<div class="spec">
<p><tt>fetch(Key, IndexNum, MI) -&gt; Value</tt>
<ul class="definitions"><li><tt>Key = term()</tt></li>
<li><tt>IndexNum = integer()</tt></li>
<li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
<li><tt>Value = term()</tt></li>
</ul></p>
</div><p>Fetches and returns a single element from the multi index
  <code>MI</code> whose key for index number <code>IndexNum</code> matches
  <code>Key</code>.  Assumes that a matching value is present, crashes
  otherwise. If this can happen, use <a href="#fetch_all-2"><code>fetch_all/2</code></a> instead. If
  <code>IndexNum</code> is a non-unique index and more than one matching value
  is found, it is unspecified which one is returned.</p>

<h3 class="function"><a name="fetch_all-3">fetch_all/3</a></h3>
<div class="spec">
<p><tt>fetch_all(Key, IndexNum, MI) -&gt; [Value]</tt>
<ul class="definitions"><li><tt>Key = term()</tt></li>
<li><tt>IndexNum = integer()</tt></li>
<li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
<li><tt>Value = term()</tt></li>
</ul></p>
</div><p>Looks up and returns a possibly empty list of all values in the multi
  index <code>MI</code> and whose key for index number <code>IndexNum</code>
  matches <code>Key</code>. If <code>IndexNum</code> is a non-unique index and
  more than one matching value is found, it is unspecified which order the
  values are returned in.</p>

<h3 class="function"><a name="from_list-2">from_list/2</a></h3>
<div class="spec">
<p><tt>from_list(Values, Indices) -&gt; <a href="#type-multi_index">multi_index()</a></tt>
<ul class="definitions"><li><tt>Values = [term()]</tt></li>
<li><tt>Indices = [<a href="#type-index">index()</a>]</tt></li>
</ul></p>
</div><p>Returns a new multi index whose elements are the elements in
  <code>Values</code>, and with indicse <code>Indices</code>. Assumes that no
  value in <code>Values</code> contains a key conflict with any other value in
  <code>Values</code>, crashes if this happens.  If a different behavior is
  needed, <code>lists:foldl</code> should be used to build up a new multi
  index instead.</p>
<p><b>See also:</b> <a href="#new-1">new/1</a>.</p>

<h3 class="function"><a name="indices-1">indices/1</a></h3>
<div class="spec">
<p><tt>indices(MI) -&gt; [<a href="#type-index">index()</a>]</tt>
<ul class="definitions"><li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
</ul></p>
</div><p>Returns the indices used in the multi index <code>MI</code>.</p>

<h3 class="function"><a name="insert-2">insert/2</a></h3>
<div class="spec">
<p><tt>insert(Value, MI) -&gt; <a href="#type-multi_index">multi_index()</a></tt>
<ul class="definitions"><li><tt>Value = term()</tt></li>
<li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
</ul></p>
</div><p>Inserts the element <code>Value</code> into the multi index
  <code>MI</code> and returns the resulting multi index.  Assumes that
  <code>Value</code> does not contain a key conflict with any value in
  <code>MI</code>, crashes otherwise. If this can happen, use <a href="#try_insert-2"><code>try_insert/2</code></a> instead.</p>

<h3 class="function"><a name="new-1">new/1</a></h3>
<div class="spec">
<p><tt>new(Indices) -&gt; <a href="#type-multi_index">multi_index()</a></tt>
<ul class="definitions"><li><tt>Indices = [<a href="#type-index">index()</a>]</tt></li>
</ul></p>
</div><p><p>Returns an empty multi index with indices <code>Indices</code>.</p>
 
  When passing indices, the first element in the list of indices is the first
  index, the second element (if any) is the second index, and so on. There
  must be at least one index given.</p>

<h3 class="function"><a name="replace-3">replace/3</a></h3>
<div class="spec">
<p><tt>replace(Value1, Value2, MI) -&gt; <a href="#type-multi_index">multi_index()</a></tt>
<ul class="definitions"><li><tt>Value1 = term()</tt></li>
<li><tt>Value2 = term()</tt></li>
<li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
</ul></p>
</div><p>Replaces all instances of <code>Value1</code> with <code>Value2</code>
  in the multi index <code>MI</code> and returns the resulting multi index.
  Assumes at least one <code>Value1</code> exists in <code>MI</code>, crashes
  otherwise.</p>

<h3 class="function"><a name="size-1">size/1</a></h3>
<div class="spec">
<p><tt>size(MI) -&gt; integer()</tt>
<ul class="definitions"><li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
</ul></p>
</div><p>Returns the number of elements stored in the multi index
  <code>MI</code>.</p>

<h3 class="function"><a name="to_list-2">to_list/2</a></h3>
<div class="spec">
<p><tt>to_list(IndexNum, MI) -&gt; [Value]</tt>
<ul class="definitions"><li><tt>IndexNum = integer()</tt></li>
<li><tt>MI = <a href="#type-multi_index">multi_index()</a></tt></li>
<li><tt>Value = term()</tt></li>
</ul></p>
</div><p>Returns a list of all values in the multi index <code>MI</code>, in the
  order of their keys for index number <code>IndexNum</code>. If
  <code>IndexNum</code> is a non-unique index and multiple values with the
  same key are found, it is unspecified which order the equal keyed values are
  placed in the list relative to each other.</p>

<h3 class="function"><a name="try_insert-2">try_insert/2</a></h3>
<div class="spec">
<p><tt>try_insert(Value, MI1) -&gt; {ok, MI2} | error</tt>
<ul class="definitions"><li><tt>Value = term()</tt></li>
<li><tt>MI1 = <a href="#type-multi_index">multi_index()</a></tt></li>
<li><tt>MI2 = <a href="#type-multi_index">multi_index()</a></tt></li>
</ul></p>
</div><p>Attempt to insert the element <code>Value</code> into the multi index
  <code>MI1</code>. If the element can be inserted, multi index
  <code>MI2</code> is created with that element inserted and <code>{ok,
  MI2}</code> is returned. If the element cannot be inserted because it
  violates a unique key constraint in <code>MI1</code>, then
  <code>error</code> is returned.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Sep 3 2010, 14:14:44.</i></p>
</body>
</html>
